※ 프로그래밍기초 2팀 14주차 회의록
20173439 우상욱(팀장)
20173453 최수창
20173504 박찬우

헤더 파일에 속한 대표적인 기능들
imgproc.hpp
이미지를 처리하는 기능들이 대부분 포홤된 헤더 파일
가져온 이미지에서 특정 부분을 찾거나, 후처리하거나 하는 기능들이 모여있다.
class - 
cv :: LineIterator : 라인 반복자
cv :: LineSegmentDetector : 선분 검출기 클래스.
함수들도 이미지 처리를 담당하는 함수들이다.
불러온 이미지에 추가 도형을 그리거나, 이미지에 후처리를 하는 등의 기능이 있다.
func : 
cv :: applyColorMap : 이미지에 사용자 설정 컬러 맵 적용함
cv :: arrowedLine : 첫 번째 점에서 두 번째 점을 가리키는 화살표 세그먼트 그림
cv :: blur : 필터를 이용하여 이미지를 흐리게 함(normalized box filter)
cv :: boxPoints : 직사각형의 4개의 정점을 찾음. 회전된 직사각형 그리는데 유용.
cv :: circle : 원을 그림
cv :: findContours : 이진 이미지에서 윤곽선을 찾음
cv :: GaussianBlur : 가우시안 필터를 이용해 이미지를 흐리게 함
cv :: line : 두 점을 연결하는 점을 그림
cv :: resize : 이미지 크기를 조정함

highgui.hpp
실행되는 창의 ui를 담당하는 텍스트를 출력하고, 실행창의 ui를 관리하는 헤더이다.
실행창(cmd x)창의 ui, 그리고 실행되는 이미지의 ui모두 담당한다. 실행 창에 ui를 만들어 수치를 조정할
수도 있다. ex)마우스를 따라 선이 그려지는 기능을 구현, 트랙 바를 조정해 그려지는 선의 색(RGB)수치를
조정하며 선을 그릴 수도 있다. 실행창의 위치 , 사이즈, 개수 등 창에 대한 기능을 담당한다.
func
cv :: addText : 이미지에 텍스트를 그림.
cv :: createButton : 버튼을 만들고 연결
cv :: createTrackbar : 트랙 바를 만들고 연결
cv :: displayOverlay : 지정된 기간 동안 창 이미지에 텍스트를 오버레이로 표시
cv :: displayStatusBar : 지정된 시간 동안 창 상태 표시줄에 텍스트 표시
cv :: imshow : 지정된 창에 이미지를 표시
cv :: resizeWindow : 창을 지정된 크기로 표시
cv :: setTrackbarPos : 트랙 바 위치를 설정합니다.
cv :: setTrackbarPos : 트랙 바 위치를 반환합니다.
cv :: destroyWindow : 지정된 창을 파괴합니다
cv :: destroyAllWindows : 모든 HighGui창을 반환합니다.

============================================================================
OpenCVBOT의 main에서 사용된 기능들

imshow(winname, filename) : 이미지를 모니터에 보여줌
winname: 이미지 창 이름
filename: 파일 명
-----------------------------------------------------------------------------
cvtColor(Mat 입력영상, Mat 출력영상, 변환형식(ex BGR2GRAY)) : 이미지의 기본BRG컬러를 회색(흑백)으로 바꿈
-----------------------------------------------------------------------------
 void absdiff(
       InputArray src1, // 첫 번째 입력 배열 또는 행렬
       InputArray src2, // 두 번째 입력 배열 또는 행렬
       OutputArray dst // 결과 배열 또는 행렬
      ) : 입력된 두 개의 배열/행렬을 대응되는 쌍 간의 차이 요소를 계산하여 해당 배열의 요소와 해당 차이의 절대값을 대상 배열의 해당 요소에 배치
-----------------------------------------------------------------------------
threshold(img, threshhold_value, value, flag) : 입력된 이미지에서 이미지의 픽셀값이 문턱값보다 크거나 작으면 특정 고정값을 할당
img: 이미지
threshhold_value: 픽셀 문턱값
value: 픽셀 문턱값보다 크거나 작을 때 적용되는 최대값
flag: THRESH_BINARY :　픽셀값이 threshhold_value보다 크면 value, 작으면 0으로 할당
-----------------------------------------------------------------------------
Rect(int x, int y, int width, int height) : 사각형 영역 지정(x좌표 시작점, y좌표 시작점, 밑변, 높이)
-----------------------------------------------------------------------------
Mat.copyto( OutputArray m ) : m에 Mat를 복사함
-----------------------------------------------------------------------------
morphologyEx(noGrass, noGrass, MORPH_CLOSE, kernel) : noGrass에 대해 closing기법 수행 (안쪽으로 침식)	
-----------------------------------------------------------------------------
medianBlur(src, dst, d) : 이 필터는 선형으로 처리되지 않고, 엣지와 노이즈를 줄여주어 부드러운 영상이 만들어지게 된다. 변수의 값이 크면 클수록 픽셀에 미치는 영향이 많아져 가중치가 커지게 된다.
src : 입력 이미지
dst : 출력 이미지
d : 필터링에 이용하는 이웃한 픽셀의 지름을 정의
-----------------------------------------------------------------------------
approxPolyDP() :　물체의 외곽선인 컨투어를 근사화하여 직선으로 바꾸기 위해서 사용되는 함수
-----------------------------------------------------------------------------
medianBlur() : 블러처리하는 함수
-----------------------------------------------------------------------------
rectangle() : 사각형을 그리는 함수(입출력 이미지파일, 시작점(좌상단), 종료점(우하단), 색상, 선두께, 선종류(디폴트 8), fractional bit)
-----------------------------------------------------------------------------
waitKey(ms) : ms밀리세컨만큼 대기, 0일시 무한 대기
=============================================================================
BOOL StretchBlt(
    HDC hdcDest, //이미지를 출력할 위치의 핸들
    int nXOriginDest, // 이미지를 출력할 좌표인 x, y
    int nYOriginDest, // 이미지를 출력할 좌표인 x, y
    int nWidthDest, // 출력할 이미지의 너비, 높이  이 크기만큼 hdcsSrc로부터 받은 이			미지를 이 너비와 높이에 맞게 이미지 크기를 변경합니다.
    int nHeightDest,// 출력할 이미지의 너비, 높이 
    HDC hdcSrc, // 이미지의 핸들
    int nXOriginSrc, // 가져올 이미지의 시작점인 x 좌표
    int nYOriginSrc, // 가져올 이미지의 시작점인y 좌표 지정한 위치부터 nWidthSrc, nHeightSrc 만큼 이미지를 잘라옴
    int nWidthSrc, // 원본 이미지로부터 해당 크기만큼 잘라낼 이미지의 너비, 높이
    int nHeightSrc, // 원본 이미지로부터 해당 크기만큼 잘라낼 이미지의 너비, 높이
이 크기만큼 원본 이미지에서 잘라내어 nWidthDest, nHeightDest의 크기에 맞게 이미지 크기를 변경합니다.
    DWORD dwRop); // 이미지 출력 방법 SRCCOPY 원본 이미지를 출력합니다.

> GDI Object List : Pen, Brush, Font, Bitmap, Region, Palette

BOOL DeleteObject ( HGDIOBJ ho );
 HGDIOBJ ho : 제거할 GDI 오브젝트의 핸들
        Return value : GDI 오브젝트 제거에 성공한 경우 0이아닌 값 반환
			핸들이 없거나, 현재 DC에 선택된 경우 0 반환
   > BOOL DeleteDC ( HDC hDC );
        HDC hDC : 해제할 DC의 핸들
        Return value : DC가 해제 된 경우 0이아닌 값, 그 반대는 0 반환	
DeleteDC는 화면에 안보이고 메모리상에 할당된 DC 해제를 위해 사용
ex) CreateDC, CreateCompatibleDC
   > int ReleaseDC ( HWND hWnd, HDC hDC );
        HWND hWnd : 해제할 DC의 윈도우 핸들
        HDC hDC : 해제할 DC의 핸들
        Return value : DC가 해제 된 경우 1, 그 반대는 0 반환
ReleaseDC는 화면에 직접적으로 보이는 DC 해제를 위해 사용
   ex) GetDC, GetWindowDC
Rect_는 2차원의 사각형 정보를 나타내기 위한 템플릿 클래스이다. - >Rect로 typedef 되어있음.
멤버 변수로 시작 좌표(x,y)와 크기(width,height) 정보를 포함한다.
left
number. 좌측 상단의 x좌표
top
number. 좌측 상단의 y좌표
right
number. 우측 하단의 x좌표
bottom
number. 우측 하단의 y좌표

void findContours(InputArray image, OutputArrayOfArrays contours,
                  OutputArray hierarchy, int mode,
                  int method, Point offset = Point());
void findContours(InputArray image, OutputArrayOfArrays contours,
                  int mode, int method, Point offset = Point());
• image
입력 영상. 8비트 1채널 영상이어야 하고, 0이 아닌 픽셀을 객체로 취급합니다. 만약 mode가 RETR_CCOMP이면 CV_32SC1 타입의 영상을 지정할 수 있습니다.
• contours
검출된 외곽선 정보. vector<vector<Point>> 타입의 변수를 지정합니다.
• hierarchy
외곽선 계층 정보. vector<Vec4i> 타입의 변수를 지정합니다.

• mode
외곽선 검출 모드. RetrievalModes 열거형 상수를 지정합니다.
• method
외곽선 근사화 방법. ContourApproximationModes 열거형 상수를 지정합니다.
• offset
외곽선 점 좌표의 오프셋(이동 변위)

at( int x, int y )
각 원소에 접근하기 위한 방법으로 Mat의 at 메소드를 이용할 수 있습니다. at은 컴파일 시 타입을 필요로 함. 이는 처리할 영상이 컬러인지 그레이인지, 어떤 데이터가 들어있는지를 알아야 하기 때문입니다. 이러한 타입 설정은
image.at<uchar>(j,i) = 255;
image.at<cv::Vec3b>(j,i)[channel] = 255; // channel - >접근할 채널
로 코드로 표현 가능.  Vec3b는 컬러이미지에 사용되고  컬러는 채널이 3개이기 때문에 배열 , 인덱스 방식을 사용함.
Vec3b color = img1.at<Vec3b>(Point(300, 170));	//check if isn't night, if is jump	mat데이터 구조	opencv 픽셀 값 접근하기
Image.at<Vec3b>(x, y)[0];           // Blue
Image.at<Vec3b>(x, y)[1];        // Green
Image.at<Vec3b>(x, y)[2];           // Red
-============================================================================
Mat hwnd2mat(HWND hwnd) 
Class MAT
Mat클래스는 행렬(Matrix)를 뜻하며, OpenCV에서 가장 많이 사용하는 클래스이다.
Mat클래스는 n차원의 고차원 행렬까지 표현할 수 있으며, 영상 처리 라이브러리 답게, 한 개 이상의 채널을 가질 수 있다. (영상이라는 게 사진의 연속이고 사진이 곧 행렬이라 할 수 있다.)
정수, 실수, 복소수 등으로 구성된 행렬과 벡터, 그리고 그레이 스케일, 컬러 영상, 그리고 경우에 따라서 벡터 필드, 포인트 클라우드, 텐서, 히스토그램 등 정보를 저장하는 용도로도 사용된다. (본질적으론 행렬 관련 데이터 처리를 실행 가능하지만 주 기능은 영상 처리이다.)

/ / Mat클래스의 함수. 입력 파라미터(윈도우의 핸들 HWND)
Hwnd는 Window.h 헤더파일 필요. 
Handle 핸들이란, 구체적인 어떤 대상에 붙여진 번호이며 32비트 정수값이다.
윈도우에서는 윈도우 핸들을 붙여 윈도우를 번호로 관리한다. 왜냐하면 대상끼리의 구분을 위해서는 문자열보다 정수를 사용하는 것이 훨씬 더 속도가 빠르기 때문이다.
핸들의 특징
① 일단 핸들은 정수값이며 대부분의 경우 32비트값이다. 핸들을 사용하는 목적은 오로지 구분을 위한 것이므로 핸들끼리 중복되지 않아야하며 이런 목적으로는 정수형이 가장 적합하다.
② 핸들은 운영체제가 발급해 주며 사용자는 쓰기만 하면 된다. 예를 들어 윈도우를 만들거나 파일을 열면 운영체제는 만들어진 윈도우나 열려진 파일에 핸들을 붙여준다. 사용자는 이 핸들을 잘 보관해 두었다가 해당 윈도우나 파일을 다시 참조할 때 핸들을 사용하면 된다. 사용자가 직접 핸들을 만들 경우란 없다.
③ 같은 종류의 핸들끼리는 절대로 중복된 값을 가지지 않는다. 만약 이렇게 된다면 핸들은 구분을 위해 사용할 수 없을 것이다. 물론 다른 종류의 핸들끼리는 중복된 값을 가질 수도 있다.
④ 핸들은 정수형이므로 값을 가지겠지만 그 실제값이 무엇인지는 몰라도 상관없다. 핸들은 크고 작음의 성질을 가지는 숫자가 아니라 단순한 표식일 뿐이다. 핸들형 변수를 만들어 핸들을 대입받아 쓰고 난 후에는 버리면 된다.
윈도우즈에서 핸들은 예외없이 접두어 h로 시작되며 핸들값을 저장하기 위해 별도의 데이터형까지 정의해 두고 있다. HWND, HPEN, HBRUSH, HDC 등이 핸들을 담기 위한 데이터형들이며 모두 부호없는 정수형이다.
HWND = Handle Windows의 약자로 윈도우의 핸들 번호를 저장해서 사용한다. 하나의 프로그램에서 많은 양의 윈도우를 띄울수 있다. 즉 윈도우창의 번호들(HWND)로 구분하는 것.
HDC hwindowDC, hwindowCompatibleDC;  // dc에 대한 핸들 datatype
DC를 알기 전 윈도우의 구성에 대해서 알아야한다.
윈도우는 크게 세가지로 “동적 연결 라이브러리”를 구성한다고 말할 수 있다.
동적 연결 라이브러리란?(Dynamic Link Library)
DLL은 실행파일의 일부로 포함되지 않고 독립적으로 저장되는 라이브러리이다. 
크게 정적 라이브러리는 프로그램에 미리 매핑되어 가상 메모리에 올라가 있고 프로그램이 실행될 때 가상 메모리의 일부를 메인 메모리에 올리지만, 동적 라이브러리는 프로그램에 매핑은 되지만 별도의 DLL파일이 존재해서 필요할 때 할당을 해준다.

크게 동적 연결 라이브러리를 구성하는 세가지
 - Kernel : 메모리를 관리하고 프로그램 실행을 담당
 - GDI : 화면 처리와 그래픽을 담당
 - User : User Interface와 Window를 관리

그러면 이 동적 연결 라이브러리는 왜 존재하는 것인가?
쉽게 생각해서 만약 동적 연결 라이브러리가 없다면 우리는 화면상에 그래픽을 뿌릴 수 없고, 그런 작업을 다 수작업으로 해야한다. 우리가 API를 쉽게 사용할 수 있는 것도 동적 연결 라이브러리가 있기 때문이다. 즉 우리는 동적 연결 라이브러리를 통해서 쉽고 편하게 코딩을 할 수 있는 환경을 제공 받고있다.
그러면 DC는 어느 동적 연결 라이브러리에 속해 있는가?
바로 GDI에 속해있다. 그렇다면 1. DC는 GDI 즉 "동적 연결 라이브러리" 에 속해 있으므로 그래픽 관련해서 일을 할 것이다.
2. DC는 이미지 관련해서 사용하는 함수 일 것이다. 라는 예측을 할 수 있다.
그래서 DC는 출력에 필요한 모든 정보를 가지는 데이터 구조체 이다.
DC는 GDI에 의해 관리가 되고, 어떤 폰트, 색상, 굵기, 출력 방법 등이 모두 출력에 필요한 정보로써 이런 정보를 다 담고 있다.
그러면 DC를 어떻게 사용하는가?
- LineTo(hDC, X, Y)      : 선의 색상, 굵기, 모양 등의 정보를 모두 모아 DC에 넣고 DC의 핸들을 넘겨 받아 그립니다.
 - LineTo(hDC, 100, 100) : 화면에 여러개 창이 있는 경우 내가 지정한 창을 찾아 LineTo 함수를 실행합니다.
첫번째 인수에 hDC라는 변수가 들어가있다. 다른 예를 보자.
 hdc = GetDC(hWnd);  //!< GetDC로 현재 DC 핸들값을 가져옵니다.
 TextOut(hdc, 100, 100, "HelloWorld", 20); 
 ReleaseDC(hWnd, hdc);
문자열을 출력하기 전에는 Get DC함수로 DC정보를 받고, 그다음에 문자열을 출력하고 ReleaseDC함수로 DC를 삭제하는 형식으로 사용한다.
DC는 출력을 하기 위해서 필요한 개체이다.
그렇다면 모든 경우에 DC를 받을 수 있는가?
DC를 얻는 방법에는 2가지가 있다.
1. 첫번째 : GetDC함수를 사용해서 DC를 얻고 ReleaseDC로 해체 하는 방법
HDC GetDC(HWND hWnd);
int ReleaseDC(HWND hWnd, HDC hDC);
우리는 첫번째를 사용하고있으니 첫번째만 알아봤다.
HDC는 Handle Devide Context로써 DC의 정보를 저장하는 데이터 구조체의 위치를 알기 위한 것으로, 항상 실제 객체의 메모리 주소를 가르킨다. -> 물리적으로 메모리 주소가 바뀌어도 DC의 실제 위치를 찾아간다.
HDC : Handle Device Context 
Device Context : 출력에 필요한 정보를 가지는 데이터 구조체. 좌표, 색 , 굵기 등 출력에 필요한 모든 정보를 담고 있다.
HDC : 윈도우의 출력에 관한 많은 정보를 보관하고 있는 구조체, 기본제공 도형, 선 , 이미지 출력, 폰트까지 대부분의 윈도우 환경의 출력정보를 관리하는 역할.



 (채널) - > 이번 프로젝트에서 알아야할 개념
영상에서 채널이란, 예로 그레이스케일과 RGB컬러가 있다.
하나의 장면일지라도 영상의 색을 나타내는 방식이 그레이 스케일의 경우에는 흑과 백, 그리고 그사이의 그라데이션으로 나뉘어지는 1차원정보로, 이를 1채널이라고 부른다.
RGB컬러의 경우에는 Red, Green ,Blue에 대한 각각의 차원을 가지는 3차원으로 빛의 삼원색에 따라서 어두운 검은색에서 시작해서 Red에 가까운지, 어두운 검은색에서 시작해서 Green에 가까운지에 대해서 3차원적인 조합으로 이루어진 3채널을 뜻한다
//
Main() 부분
HWND hwndDesktop = GetDesktopWindow();
GetDesktopWindow : 바탕화면의 핸들을 얻기 위한 함수
